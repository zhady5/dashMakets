{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "0fb150b2-e9d6-4a65-965b-6dcdeaf1a45d",
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "[nltk_data] Downloading package brown to\n",
      "[nltk_data]     C:\\Users\\DNS\\AppData\\Roaming\\nltk_data...\n",
      "[nltk_data]   Package brown is already up-to-date!\n"
     ]
    }
   ],
   "source": [
    "import os\n",
    "import numpy as np\n",
    "import pandas as pd\n",
    "import math\n",
    "\n",
    "import random\n",
    "import datetime\n",
    "from dateutil.relativedelta import relativedelta\n",
    "from babel.dates import format_date\n",
    "\n",
    "import nltk\n",
    "nltk.download('brown')\n",
    "from nltk.corpus import brown\n",
    "\n",
    "import plotly\n",
    "import plotly.graph_objects as go\n",
    "import plotly.express as px\n",
    "from plotly.subplots import make_subplots\n",
    "\n",
    "import dash\n",
    "from dash import dcc, html, callback, Input, Output, State, dash_table\n",
    "import dash_bootstrap_components as dbc\n",
    "\n",
    "from IPython.display import display\n",
    "\n",
    "from PIL import ImageColor\n",
    "\n",
    "from io import BytesIO\n",
    "from wordcloud import WordCloud\n",
    "import base64\n",
    "\n",
    "import string\n",
    "from collections import Counter"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "1f21936d-534c-4b8c-bc3a-9508e2eef8ce",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Указываем путь к папке с файлами\n",
    "folder_path = os.getcwd()\n",
    "\n",
    "# Получаем список файлов в папке\n",
    "file_list = sorted([f for f in os.listdir(folder_path) if f.endswith('.csv')])\n",
    "\n",
    "channels = pd.read_csv(folder_path + file_list[0])\n",
    "posts = pd.read_csv(folder_path + file_list[1])\n",
    "reactions = pd.read_csv(folder_path + file_list[2])\n",
    "subscribers = pd.read_csv(folder_path + file_list[3])\n",
    "views = pd.read_csv(folder_path + file_list[4])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "id": "613401b3-efec-4bf2-ad75-421aee21529c",
   "metadata": {},
   "outputs": [],
   "source": [
    "def load_stopwords_from_file(file_path):\n",
    "    with open(file_path, 'r', encoding='utf-8') as file:\n",
    "        stopwords = [line.strip() for line in file]\n",
    "    return stopwords\n",
    "\n",
    "file_path = 'stopwords-ru.txt'  # Укажите путь к вашему файлу со стоп-словами\n",
    "puncts = set(list(string.punctuation) + ['—', '»', '«', '``', '–', \"''\"])\n",
    "stopwords_ru = set(load_stopwords_from_file(file_path))\n",
    "predlogi = set(['без' , 'в' , 'до' , 'для' , 'за' , 'из' , 'к' , 'на' , 'над' , 'о' , 'об' , 'от' , 'по' , 'под' , 'пред' , 'при' , 'про' , 'с' , 'у' , 'через']) \n",
    "souzy = set(['а' , 'и' , 'чтобы' , 'если', 'потому что' , 'как будто' , 'то есть'])\n",
    "exclude = set(['например', 'какие', 'кто-то', 'что-то', 'кстати', 'многие', 'таких', 'может', 'любой', 'поэтому', 'https'])\n",
    "numbers = set('1234567890')\n",
    "dell_words = stopwords_ru | predlogi | souzy | numbers | exclude"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "id": "7d40d342-4bce-45cb-95ae-faa00e6f5f4e",
   "metadata": {},
   "outputs": [],
   "source": [
    "def convert_date(date):\n",
    "    try:\n",
    "        return datetime.datetime.strptime(date,'%Y-%m-%d %H:%M:%S.%f')\n",
    "    except ValueError:\n",
    "        # Если строка не может быть преобразована в дату, возвращаем NaT (Not a Time)\n",
    "        return pd.NaT\n",
    "\n",
    "# Функция для определения градиентной заливки\n",
    "def get_gradient_color(value, min_val=0, max_val=100):\n",
    "    # Если значение равно нулю, возвращаем прозрачный цвет\n",
    "    if value == 0:\n",
    "        return \"transparent\"\n",
    "    \n",
    "    # Рассчитываем процентное соотношение между минимальным и максимальным значением\n",
    "    ratio = (value - min_val) / (max_val - min_val)\n",
    "    # Ограничиваем диапазон значений\n",
    "    ratio = max(min(ratio, 1), 0)\n",
    "\n",
    "     # Начальные и конечные значения RGB\n",
    "    start_r, start_g, start_b = 139, 0, 0 #245, 223, 191  # Бежевый (#f5dfbf)\n",
    "    end_r, end_g, end_b = 34, 139, 34          # Зелёный (#228B22)\n",
    "    \n",
    "    # Рассчитываем промежуточные значения RGB\n",
    "    r = int(start_r * (1 - ratio) + end_r * ratio)\n",
    "    g = int(start_g * (1 - ratio) + end_g * ratio)\n",
    "    b = int(start_b * (1 - ratio) + end_b * ratio)\n",
    "    \n",
    "    color = '#%02x%02x%02x' % (r, g, b)\n",
    "    return color\n",
    "\n",
    "def create_table(post_view, max_days, channel):\n",
    "    \n",
    "    filtered_post_view = post_view[(post_view['days_diff'] <= max_days)&(post_view.channel_name==channel)].copy()\n",
    "    filtered_post_view = filtered_post_view.groupby(['post_datetime', 'post_id'\n",
    "                                                     , 'current_views', 'days_diff'])[['view_change', 'percent_new_views']].sum().reset_index()\n",
    "    grouped_df = filtered_post_view.groupby(['post_datetime', 'post_id']).agg({\n",
    "        'view_change': lambda x: list(x),\n",
    "        'percent_new_views': lambda x: list(x),\n",
    "        'current_views': lambda x: x.iloc[-1]\n",
    "    }).reset_index()\n",
    "\n",
    "    max_days = int(round(max_days))\n",
    "    \n",
    "    columns = [\"ID поста\", \"Дата публикации\", \"Текущие просмотры\"] + [f\"{i} д\" for i in range(1, max_days+1)]\n",
    "    data = []\n",
    "    \n",
    "    for _, row in reversed(list(grouped_df.iterrows())):\n",
    "        view_change = row['view_change']\n",
    "        percent_new_views = row['percent_new_views']\n",
    "        current_views = row['current_views']\n",
    "        \n",
    "        row_data = [\n",
    "            html.Td(f\"{row['post_id']}\"),\n",
    "            html.Td(f\"{datetime.datetime.strptime(row['post_datetime'], \"%Y-%m-%d %H:%M:%S.%f\").strftime(\"%b %d, %Y\")}\", style={\"text-align\": \"center\"}),\n",
    "            html.Td(current_views)\n",
    "        ]\n",
    "        for day in range(1, max_days+1):\n",
    "            if day <= len(view_change):\n",
    "                cell_value = f\"{view_change[day-1]} ({percent_new_views[day-1]:.2f}%)\"\n",
    "                \n",
    "                # Проверяем процентное значение\n",
    "                if percent_new_views[day-1] >= 80:\n",
    "                    text_color = \"#228B22\"  # Зеленый цвет\n",
    "                else:\n",
    "                    # Используем функцию для получения градиентного цвета\n",
    "                    text_color = get_gradient_color(percent_new_views[day-1])\n",
    "                    \n",
    "                row_data.append(html.Td(cell_value, style={\"color\": text_color\n",
    "                                                           , \"font-weight\": \"bold\"\n",
    "                                                           , 'text-align': 'center'}))  # Изменение стиля текста\n",
    "            else:\n",
    "                row_data.append(html.Td(\"-\", style={\"text-align\": \"center\"}))\n",
    "     \n",
    "        data.append(html.Tr(row_data))\n",
    "        \n",
    "    return html.Table([\n",
    "        html.Thead(html.Tr([html.Th(col) for col in columns])),\n",
    "        html.Tbody(data)\n",
    "    ], className=\"tgstat-table\")\n",
    "\n",
    "\n",
    "\n",
    "def hex_to_rgb(hex_code):\n",
    "    \"\"\"Преобразует HEX-код в RGB.\"\"\"\n",
    "    rgb = ImageColor.getcolor(hex_code, \"RGB\")\n",
    "    return rgb\n",
    "\n",
    "def interpolate_color(start_color, end_color, steps):\n",
    "    \"\"\"Интерполирует цвет между двумя значениями RGB.\"\"\"\n",
    "    start_r, start_g, start_b = start_color\n",
    "    end_r, end_g, end_b = end_color\n",
    "    step_r = (end_r - start_r) / steps\n",
    "    step_g = (end_g - start_g) / steps\n",
    "    step_b = (end_b - start_b) / steps\n",
    "    return [(int(start_r + i * step_r),\n",
    "             int(start_g + i * step_g),\n",
    "             int(start_b + i * step_b)) for i in range(steps)]\n",
    "\n",
    "def gradient_color_func(word=None, font_size=None, position=None, orientation=None, font_path=None, random_state=None):\n",
    "    start_color = hex_to_rgb('#8B0000')\n",
    "    end_color = hex_to_rgb('#ffb347')\n",
    "    num_steps = 50  # Количество шагов равно количеству слов\n",
    "    colors = interpolate_color(start_color, end_color, num_steps)\n",
    "    index = random.randint(0, num_steps - 1)  # Случайное число от 0 до количества слов\n",
    "    r, g, b = colors[index]\n",
    "    return f\"rgb({r}, {g}, {b})\"\n",
    "    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "id": "9ae00e23-fd9e-471f-bd5d-b601d924636c",
   "metadata": {},
   "outputs": [],
   "source": [
    "#CHANNELS\n",
    "\n",
    "# что за переменнная channel_type varchar(50)?\n",
    "\n",
    "\n",
    "#POSTS\n",
    "\n",
    "# date - datetime or date? if datetime - change code, else - all ok\n",
    "\n",
    "posts.rename(columns={'date': 'datetime'}, inplace=True)\n",
    "posts = posts.merge(channels[['id', 'channel_name']].rename(columns={'id':'channel_id'}), on = 'channel_id', how='left')\n",
    "posts.loc[:, 'date'] = pd.to_datetime(posts.datetime).apply(lambda t: t.strftime('%Y-%m-%d'))\n",
    "posts.loc[:, 'time'] = posts.datetime.str[10:]\n",
    "posts.loc[:, 'cnt'] = posts.groupby(['channel_id', 'date'])[['message_id']].transform('count')\n",
    "posts.loc[:, 'hour'] = pd.to_datetime(posts.datetime).apply(lambda t: t.hour)\n",
    "posts = posts[(~posts.text.isnull())&(posts.text != 'Нет текста')].copy()\n",
    "\n",
    "#VIEWS\n",
    "# колонка date создавалась как основа для datetime, в исходной ее не будет (проверить, можно ли далее по коду заменить все на datetime)\n",
    "\n",
    "views.rename(columns={'timestamp': 'datetime', 'views': 'view_cnt'}, inplace=True)\n",
    "views.loc[:, 'date'] = pd.to_datetime(views.datetime).apply(lambda t: t.strftime('%Y-%m-%d'))\n",
    "view_change = views.sort_values(by = ['post_id', 'datetime'])\\\n",
    "                        .groupby('post_id')[['view_cnt']].diff()\\\n",
    "                        .rename(columns={'view_cnt':'view_change'})\n",
    "\n",
    "views = views.merge(view_change, left_index = True, right_index=True)\n",
    "views.loc[:, 'view_change'] = np.where(views.view_change.isnull(), views.view_cnt, views.view_change)\n",
    "\n",
    "#SUBSCRIBERS\n",
    "# колонка date создавалась как основа для datetime, в исходной ее не будет (проверить, можно ли далее по коду заменить все на datetime)\n",
    "\n",
    "subs = subscribers.copy()\n",
    "subs.rename(columns={'timestamp': 'datetime', 'subscriber_count': 'subs_cnt'}, inplace=True)\n",
    "\n",
    "subs.loc[:, 'date'] = pd.to_datetime(subs.datetime).apply(lambda t: t.strftime('%Y-%m-%d'))\n",
    "\n",
    "subs = subs.merge(channels[['id', 'channel_name']].rename(columns={'id':'channel_id'}), on = 'channel_id', how='left')\n",
    "\n",
    "subs.sort_values(by=['channel_id', 'datetime'], inplace=True)\n",
    "subs.loc[:, 'subs_change'] =  subs.groupby('channel_id')[['subs_cnt']].diff().fillna(0) #np.hstack((np.array([np.nan]), np.diff(subs.subs_cnt, axis=0)))\n",
    "\n",
    "subs.loc[:, 'subs_change_pos'] = np.where(subs.subs_change>0, subs.subs_change, 0)\n",
    "subs.loc[:, 'subs_change_neg'] = np.where(subs.subs_change<0, subs.subs_change, 0) \n",
    "subs.loc[:, 'day_change_pos'] = subs.groupby(['channel_id','date'])[['subs_change_pos']].transform('sum')\n",
    "subs.loc[:, 'day_change_neg'] = subs.groupby(['channel_id', 'date'])[['subs_change_neg']].transform('sum')\n",
    "\n",
    "subs.datetime = pd.to_datetime(subs.datetime)\n",
    "del subscribers\n",
    "\n",
    "#REACTIONS\n",
    "# колонка date создавалась как основа для datetime, в исходной ее не будет (проверить, можно ли далее по коду заменить все на datetime)\n",
    "\n",
    "reacts = reactions.copy()\n",
    "reacts.rename(columns={'timestamp': 'datetime', 'count': 'react_cnt'}, inplace=True)\n",
    "\n",
    "reacts.loc[:, 'date'] = pd.to_datetime(reacts.datetime).apply(lambda t: t.strftime('%Y-%m-%d'))\n",
    "del reactions\n",
    "\n",
    "def date_ago(tp, num=0):\n",
    "    if tp == 'today':\n",
    "        return datetime.datetime.now().strftime(\"%Y-%m-%d\") \n",
    "    elif tp == 'yesterday':\n",
    "        return (datetime.datetime.now() - datetime.timedelta(days=1)).strftime(\"%Y-%m-%d\")\n",
    "    elif tp == 'days':\n",
    "        return (datetime.datetime.now() - datetime.timedelta(days=num+1)).strftime(\"%Y-%m-%d\")\n",
    "    elif tp == 'weeks':\n",
    "        return (datetime.datetime.now() - datetime.timedelta(days= 7*num + 1)).strftime(\"%Y-%m-%d\") \n",
    "    elif tp == 'months':\n",
    "        return (datetime.datetime.now() - relativedelta(months=num) - datetime.timedelta(days=1)).strftime(\"%Y-%m-%d\") \n",
    "    else:\n",
    "        print('Неправильно задан тип даты или не указано количество повторений (возможные типы дат: today, yesterday, days, weeks, months')\n",
    "\n",
    "\n",
    "\n",
    "#POSTS & VIEWS\n",
    "post_view = views[['post_id', 'view_cnt', 'view_change','datetime']]\\\n",
    "                    .merge(posts[['id', 'channel_name', 'date','datetime']].rename(columns={'id':'post_id', 'datetime':'post_datetime'})\n",
    "                        , on='post_id')[['channel_name', 'post_id', 'post_datetime', 'datetime', 'view_cnt', 'view_change']]\\\n",
    "                    .sort_values(by=['channel_name','post_id', 'datetime'])\n",
    "post_view = post_view.reset_index().drop('index', axis=1)\n",
    "\n",
    "post_view.loc[:, 'hours_diff'] = (pd.to_datetime(post_view.datetime) - pd.to_datetime(post_view.post_datetime))\\\n",
    "                                                                            .apply(lambda t: math.ceil(t.total_seconds()/3600))\n",
    "post_view.loc[:, 'days_diff'] = (pd.to_datetime(post_view.datetime) - pd.to_datetime(post_view.post_datetime))\\\n",
    "                                                                            .apply(lambda t: math.ceil(t.total_seconds()/(3600*24)))\n",
    "\n",
    "bins = list(range(0, 74))\n",
    "labels = list(range(1, 74))\n",
    "post_view.loc[:, 'hours_group'] = pd.cut(post_view['hours_diff'], bins=bins, labels=labels).fillna(73)\n",
    "\n",
    "# Рассчитываем процент новых просмотров относительно общего количества просмотров\n",
    "post_view['current_views'] = post_view.groupby('post_id')['view_cnt'].transform('last')\n",
    "post_view['percent_new_views'] = (post_view['view_change'] / post_view['current_views']) * 100\n",
    "post_view = post_view.sort_values(by=['channel_name', 'post_datetime'], ascending=False)\n",
    "\n",
    "\n",
    "\n",
    "#POSTS & VIEWS & REACTIONS\n",
    "group_reacts = reacts.groupby(['post_id', 'reaction_type'])[['datetime', 'react_cnt']].last().reset_index()\n",
    "group_post_view = post_view.groupby(['channel_name', 'post_datetime','post_id',  'current_views'])[['datetime']].last().reset_index()\n",
    "#date_format\n",
    "group_reacts.loc[:, 'datetime_format'] = group_reacts.datetime.apply(lambda date: convert_date(date).strftime('%Y-%m-%d %H:%M:%S'))\n",
    "group_post_view.loc[:, 'datetime_format'] = group_post_view.datetime.apply(lambda date: convert_date(date).strftime('%Y-%m-%d %H:%M:%S'))\n",
    "#drop\n",
    "group_reacts.drop('datetime', axis=1, inplace=True)\n",
    "group_post_view.drop('datetime', axis=1, inplace=True)\n",
    "#merge & create exclude lists\n",
    "gr_pvr = group_post_view.merge(group_reacts, on = ['post_id', 'datetime_format'], how='left').drop_duplicates()\n",
    "noreact = gr_pvr[gr_pvr.react_cnt.isnull()].post_id.unique()  #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n",
    "gr_pvr = gr_pvr[~gr_pvr.post_id.isin(noreact)].copy()\n",
    "no_post_have_react = list(set(group_reacts.post_id) - set(gr_pvr.post_id)) #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n",
    "#\n",
    "#group_reacts.shape[0] - gr_pvr.shape[0] #????????? where 7 \n",
    "#\n",
    "#new fields\n",
    "gr_pvr.loc[:, 'react_cnt_sum'] = gr_pvr.groupby('post_id')[['react_cnt']].transform('sum')\n",
    "gr_pvr.loc[:, 'idx_active'] = round(gr_pvr.react_cnt_sum/gr_pvr.current_views*100,2)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "id": "4efc4e05-55de-47a3-a10a-34dffef612fa",
   "metadata": {},
   "outputs": [],
   "source": [
    "#-----------------------------Метрики по подписчикам-------------------------------------------------------------------------\n",
    "#----------------------------------------------------------------------------------------------------------------------------\n",
    "\n",
    "def calculate_mean_max_subs(channel):\n",
    "    filtered_df = subs[subs.channel_name==channel][['date', 'day_change_pos', 'day_change_neg']].drop_duplicates()\n",
    "    \n",
    "    # вопрос по округлению!!!!!!!\n",
    "    mean_subs_pos, mean_subs_neg = int(round(filtered_df.day_change_pos.mean(), 0)), int(round(filtered_df.day_change_neg.mean(), 0)) \n",
    "    max_subs_pos, max_subs_neg = int(round(filtered_df.day_change_pos.max(), 0)), int(round(filtered_df.day_change_neg.min(), 0)) \n",
    "    \n",
    "    # Средний ежедневный прирост\n",
    "    # Средний ежедневный отток    \n",
    "    # Максимальный дневной прирост \n",
    "    # Максимальный дневной отток\n",
    "    \n",
    "    return mean_subs_pos, mean_subs_neg, max_subs_pos, max_subs_neg\n",
    "\n",
    "#-----------------------------Метрики по публикациям-------------------------------------------------------------------------\n",
    "#----------------------------------------------------------------------------------------------------------------------------\n",
    "\n",
    "def calculate_mean_posts(channel):\n",
    "    filtered_df = posts[posts.channel_name==channel].copy()\n",
    "    filtered_df.loc[:, 'date_week'] = pd.to_datetime(filtered_df.date).apply(lambda d: d.isocalendar().week)\n",
    "    filtered_df.loc[:, 'date_month'] = filtered_df.date.str[:7]\n",
    "\n",
    "    mean_posts_day = int(round(filtered_df.cnt.sum()/len(pd.date_range(filtered_df.date.min(), filtered_df.date.max())), 0))\n",
    "    mean_posts_week = int(round(filtered_df.groupby('date_week').cnt.sum().mean(), 0))\n",
    "    mean_posts_month = int(round(filtered_df.groupby('date_month').cnt.sum().mean(), 0))\n",
    "\n",
    "    # среднее количество публикаций в день\n",
    "    # среднее количество публикаций в неделю\n",
    "    # среднее количество публикаций в месяц\n",
    "\n",
    "    return mean_posts_day, mean_posts_week, mean_posts_month\n",
    "\n",
    "#-----------------------------Метрики по просмотрам-------------------------------------------------------------------------\n",
    "#----------------------------------------------------------------------------------------------------------------------------\n",
    "\n",
    "def calculate_mean_views(channel):\n",
    "    filtered_df = post_view[post_view.channel_name==channel].copy()\n",
    "    mean_views = int(round(filtered_df[['post_id', 'current_views']].drop_duplicates().current_views.mean(), 0))\n",
    "    \n",
    "    # Среднее количество просмотров одной публикации\n",
    "    \n",
    "    return mean_views \n",
    "\n",
    "#-----------------------------Метрики по реакциям-------------------------------------------------------------------------\n",
    "#----------------------------------------------------------------------------------------------------------------------------\n",
    "\n",
    "def calculate_mean_reacts(channel, react1='', perc1=0, react2='', perc2=0, react3='', perc3=0):\n",
    "    filtered_df = gr_pvr[gr_pvr.channel_name == channel]\n",
    "    \n",
    "    mean_reacts = int(round(filtered_df[['post_id', 'react_cnt_sum']].drop_duplicates().react_cnt_sum.mean(), 0))\n",
    "    mean_idx = round(filtered_df[['post_id', 'idx_active']].drop_duplicates().idx_active.mean(), 1)\n",
    "    \n",
    "    allReact = filtered_df[filtered_df.reaction_type.apply(len)==1].react_cnt.sum()\n",
    "    top3react = filtered_df[filtered_df.reaction_type.apply(len)==1].groupby('reaction_type').react_cnt.sum().reset_index()\\\n",
    "                                                                    .sort_values('react_cnt', ascending=False).head(3).reset_index()\n",
    "    top3react.loc[:, 'react_cnt_perc'] = round(top3react.react_cnt/allReact*100, 0)\n",
    "    cnt_react = top3react.shape[0]\n",
    "    \n",
    "    if cnt_react == 3:\n",
    "        react1, perc1 = top3react.reaction_type[0], int(top3react.react_cnt_perc[0])\n",
    "        react2, perc2 = top3react.reaction_type[1], int(top3react.react_cnt_perc[1])\n",
    "        react3, perc3 = top3react.reaction_type[2], int(top3react.react_cnt_perc[2])\n",
    "    elif cnt_react == 2:\n",
    "        react1, perc1 = top3react.reaction_type[0], int(top3react.react_cnt_perc[0])\n",
    "        react2, perc2 = top3react.reaction_type[1], int(top3react.react_cnt_perc[1])\n",
    "    elif cnt_react == 1:\n",
    "        react1, perc1 = top3react.reaction_type[0], int(top3react.react_cnt_perc[0])\n",
    "\n",
    "    # Среднее количество реакций на публикацию\n",
    "    # Средний индекс активности\n",
    "    # 3 самых популярных реакий и их доли от всех реакций \n",
    "\n",
    "    return mean_reacts, mean_idx, react1, perc1, react2, perc2, react3, perc3"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "id": "80bc92e1-4c17-41a4-9114-eaf2ba164dd0",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": [
       "\n",
       "        <iframe\n",
       "            width=\"100%\"\n",
       "            height=\"650\"\n",
       "            src=\"http://127.0.0.1:8011/\"\n",
       "            frameborder=\"0\"\n",
       "            allowfullscreen\n",
       "            \n",
       "        ></iframe>\n",
       "        "
      ],
      "text/plain": [
       "<IPython.lib.display.IFrame at 0x22808d6b050>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "# Настройка приложения Dash\n",
    "\n",
    "#[ \"https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css\"] \n",
    "external_stylesheets = [\n",
    "    'https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css',\n",
    "    'https://fonts.googleapis.com/css?family=Merriweather|Open+Sans&display=swap',\n",
    "    'Desktop/notebooks/custom-styles.css'\n",
    "]\n",
    "\n",
    "app = dash.Dash(__name__, external_stylesheets=external_stylesheets )\n",
    "\n",
    "#Добавляем выпадающий список для названия канала\n",
    "filtr_channels = sorted(channels.channel_name.unique())\n",
    "\n",
    "#-------------------------------------------------------------------------------------------------------------\n",
    "# Макет приложения\n",
    "\n",
    "server = app.server\n",
    "\n",
    "# Определение стилей\n",
    "styles = {\n",
    "    'container': {\n",
    "        'padding': '30px',\n",
    "        'maxWidth': '1200px',\n",
    "        'margin': '0 auto',\n",
    "        'backgroundColor': '#ffb347',\n",
    "        'boxShadow': '0 10px 15px rgba(0,0,0,0.05)',\n",
    "        'borderRadius': '10px'\n",
    "    },\n",
    "    'header': {\n",
    "        'backgroundColor': '#ffb347',\n",
    "        'fontFamily': 'Open Sans, sans-serif', #'Merriweather, serif',\n",
    "        'fontSize': '28px',\n",
    "        'lineHeight': '36px',\n",
    "        'color': '#333',\n",
    "        'marginTop': '20px',\n",
    "        'marginBottom': '5px',\n",
    "        \"font-weight\": \"bold\"\n",
    "    },\n",
    "    'subheader_title': {\n",
    "        'fontFamily': 'Open Sans, sans-serif',\n",
    "        'fontSize': '16px',\n",
    "        'lineHeight': '24px',\n",
    "        'color': '#666',\n",
    "        'marginBottom': '20px',\n",
    "        \"font-weight\": \"bold\"\n",
    "    },\n",
    "    'subheader': {\n",
    "        'fontFamily': 'Open Sans, sans-serif',\n",
    "        'fontSize': '14px',\n",
    "        'lineHeight': '24px',\n",
    "        'color': '#666',\n",
    "        'marginBottom': '10px',\n",
    "    },\n",
    "    'dropdown': {\n",
    "        'fontFamily': 'Open Sans, sans-serif',\n",
    "        'fontSize': '14px',\n",
    "        'lineHeight': '21px',\n",
    "        'color': '#444',\n",
    "        'backgroundColor': '#ffb347',  # Фон блока\n",
    "        'border': '3px solid #f5dfbf',  # Рамки блока\n",
    "        'borderRadius': '14px',\n",
    "        'padding': '0px 0px',\n",
    "        'marginTop': '0px',\n",
    "        'marginBottom': '0px'\n",
    "    }\n",
    ",\n",
    "        'dropdown_options': {  # Дополнительные стили для опций\n",
    "        'backgroundColor': '#f5dfbf',  # Фон выпадающего списка\n",
    "        'color': '#444'             # Цвет текста внутри опции\n",
    "    }\n",
    ",\n",
    "    'slider': {\n",
    "        'fontFamily': 'Open Sans, sans-serif',\n",
    "        'fontSize': '14px',\n",
    "        'lineHeight': '21px',\n",
    "        'color': '#444',\n",
    "        'marginBottom': '20px',\n",
    "        \"trackBackgroundColor\": \"lightgray\",  # Цвет фона дорожки ползунка\n",
    "        \"highlightColor\": \"#f5dfbf\",             # Цвет выделенной области между ползунками\n",
    "        \"handleBorderColor\": \"red\"       # Цвет рамки ползунков        \n",
    "    },\n",
    "    'graph_container': {\n",
    "        'marginBottom': '40px'\n",
    "        \n",
    "    },\n",
    "    'data_table': {\n",
    "        'fontFamily': 'Open Sans, sans-serif',\n",
    "        'fontSize': '12px',\n",
    "        'lineHeight': '21px',\n",
    "        'color': '#444',\n",
    "        'borderCollapse': 'separate', #'collapse',\n",
    "        'borderSpacing': '0',\n",
    "        'width': '100%',\n",
    "        'marginBottom': '40px'\n",
    "    },\n",
    "    'data_table_header': {\n",
    "        'backgroundColor': '#f5dfbf', #'#eaeaea',\n",
    "        'fontWeight': '600',\n",
    "        'textAlign': 'left',\n",
    "        'padding': '8px',\n",
    "        'borderBottom': '1px solid #ddd'\n",
    "    },\n",
    "    'data_table_row': {\n",
    "        'borderBottom': '1px solid #ddd',\n",
    "        'padding': '8px'\n",
    "    },\n",
    "    'data_table_cell': {\n",
    "        'padding': '8px',\n",
    "        'textAlign': 'left',\n",
    "        'border': '2px solid #ddd',\n",
    "        'border-radius': '18px'\n",
    "    }\n",
    "    , 'buttons': {\"font-size\": \"11px\"\n",
    "                  , 'margin-right': '7px'\n",
    "                  , \"background-color\": '#ffb347' \n",
    "                  , \"border-radius\": \"35px\"\n",
    "                  , \"border-width\": \"2px\"\n",
    "                  , \"border-color\": '#f5dfbf'\n",
    "                  , \"box-shadow\": \"0px\"\n",
    "                  , 'color': 'black'\n",
    "        \n",
    "    }\n",
    "    , 'metric_numbers': {\n",
    "        'fontSize': '14px'\n",
    "        , 'color': 'brown'\n",
    "        , \"font-weight\": \"bold\"      \n",
    "    }\n",
    "}\n",
    "\n",
    "# Создание компонентов фильтра для каждого столбца\n",
    "filter_components = []\n",
    "filter_columns_table_id = ['id']  #['id','date', 'time',  'text']\n",
    "columns_table_id  = ['id','date', 'time',  'text']\n",
    "label_style = {'display': 'inline-block', 'vertical-align': 'middle', 'white-space': 'nowrap'}\n",
    "for col in filter_columns_table_id :\n",
    "    filter_components.append(\n",
    "        html.Div([\n",
    "            #f\"{col}: \",\n",
    "            #html.Label(col, style=label_style),\n",
    "            dcc.Input(id=f'input_{col}'\n",
    "                      , placeholder = \"Введите номер id поста\"\n",
    "                      , type='text'\n",
    "                      , style={'width': '100%', 'margin-bottom': '10px', 'color': 'brown', \"background-color\": '#ffb347'})\n",
    "        ])\n",
    "    )\n",
    "        \n",
    "# Макет приложения\n",
    "app.layout = html.Div([\n",
    "    \n",
    "    html.Div(className='container', style=styles['container'], children=[\n",
    "\n",
    "     html.Div(className='row', style={'display': 'flex', 'margin-bottom': '40px'}, children=[\n",
    "     \n",
    "             html.Div(style={'width': '67%', 'height': '100%', 'marginRight': '30px'},  children=[   \n",
    "                html.H1('Simulative', style=styles['header']),\n",
    "                html.H2('Дашборд по анализу Telegram-каналов', style=styles['subheader_title']),\n",
    "                html.Div(className='col-md-12', children=[\n",
    "                        dcc.Dropdown(\n",
    "                            id='channel-dropdown',\n",
    "                            options=[{'label': c, 'value': c} for c in posts['channel_name'].unique()],\n",
    "                            value=posts['channel_name'].unique()[0],\n",
    "                            clearable=False,\n",
    "                            #className = 'custom-select',\n",
    "                            style=styles['dropdown']\n",
    "                                    )\n",
    "                        ])\n",
    "              ]),\n",
    "        \n",
    "                 html.Div(style={'width': '27%', 'height': '100%', 'marginLeft': '30px'},  children=[\n",
    "                      html.Img(id=\"image_wc\", style={'width': '100%', 'height': '100%'})\n",
    "                     ])\n",
    "        ])\n",
    "\n",
    " , html.Div(className='row', style={'display': 'flex',  'margin-bottom': '40px'}, children=[       \n",
    "   # Карточки с метриками\n",
    "\n",
    "     # Колонка1\n",
    "     html.Div(style={'width': '22%', 'height': '100%', 'marginRight': '30px'}, children=[    \n",
    "                    html.Div([\n",
    "                        html.Span('📈', style={'fontSize': '24px'}), \n",
    "                        html.Span('Средний ежедневный прирост  ', style={'fontSize': '12px'}),\n",
    "                        html.Span(id='mean_subs_pos', style=styles['metric_numbers'])\n",
    "                    ]),\n",
    "                    html.Div([\n",
    "                        html.Span('📉', style={'fontSize': '24px'}), \n",
    "                        html.Span('Средний ежедневный отток  ', style={'fontSize': '12px'}),\n",
    "                        html.Span(id='mean_subs_neg', style=styles['metric_numbers'])\n",
    "                    ]),\n",
    "                    html.Div([\n",
    "                        html.Span('🚀', style={'fontSize': '24px'}), \n",
    "                        html.Span('Максимальный прирост  ', style={'fontSize': '12px'}),\n",
    "                        html.Span(id='max_subs_pos', style=styles['metric_numbers'])\n",
    "                    ]),\n",
    "                    html.Div([\n",
    "                        html.Span('🆘', style={'fontSize': '24px'}), \n",
    "                        html.Span('Максимальный отток  ', style={'fontSize': '12px'}),\n",
    "                        html.Span(id='max_subs_neg', style=styles['metric_numbers'])\n",
    "                    ])\n",
    "     ]),\n",
    "\n",
    "    # Колонка2\n",
    "    html.Div(style={'width': '22%',  'height': '100%', 'marginRight': '30px'}, children=[         \n",
    "                    html.Div([\n",
    "                        html.Span('📋', style={'fontSize': '24px'}), \n",
    "                        html.Span('В среднем постов в день  ', style={'fontSize': '12px'}),\n",
    "                        html.Span(id='mean_posts_day', style=styles['metric_numbers'])\n",
    "                    ]),\n",
    "                     html.Div([\n",
    "                        html.Span('📜', style={'fontSize': '24px'}), \n",
    "                        html.Span('В среднем постов в неделю  ', style={'fontSize': '12px'}),\n",
    "                        html.Span(id='mean_posts_week', style=styles['metric_numbers'])\n",
    "                    ]),    \n",
    "                    html.Div([\n",
    "                        html.Span('🗂️', style={'fontSize': '24px'}), \n",
    "                        html.Span('В среднем постов в месяц  ', style={'fontSize': '12px'}),\n",
    "                        html.Span(id='mean_posts_month', style=styles['metric_numbers'])\n",
    "                    ]),        \n",
    "     ]),   \n",
    "\n",
    "    # Колонка3\n",
    "    html.Div(style={'width': '22%', 'height': '100%', 'marginRight': '30px'}, children=[      \n",
    "                    html.Div([\n",
    "                        html.Span('👀', style={'fontSize': '24px'}), \n",
    "                        html.Span('В среднем просмотров  ', style={'fontSize': '12px'}),\n",
    "                        html.Span(id='mean_views', style=styles['metric_numbers'])\n",
    "                    ]),   \n",
    "\n",
    " \n",
    "                    html.Div([\n",
    "                        html.Span('🐾', style={'fontSize': '24px'}), \n",
    "                        html.Span('В среднем реакций  ', style={'fontSize': '12px'}),\n",
    "                        html.Span(id='mean_reacts', style=styles['metric_numbers'])\n",
    "                    ]),   \n",
    "\n",
    "                    html.Div([\n",
    "                        html.Span('💎', style={'fontSize': '24px'}), \n",
    "                        html.Span('В среднем уровень активности  ', style={'fontSize': '12px'}),\n",
    "                        html.Span(id='mean_idx', style=styles['metric_numbers'])\n",
    "                    ]),   \n",
    "      ]),\n",
    "\n",
    "    # Колонка4\n",
    "    html.Div(style={'width': '22%', 'height': '100%', 'marginLeft': '30px'}, children=[         \n",
    "                    html.Div([\n",
    "                        html.Span('🥇', style={'fontSize': '24px'}),\n",
    "                        html.Span('  Доля реакции ', style={'fontSize': '12px'}),\n",
    "                        html.Span(id='react1', style={'fontSize': '24px'}),\n",
    "                        html.Span(':  ', style={'fontSize': '12px'}),\n",
    "                        html.Span(id='perc1', style=styles['metric_numbers'])\n",
    "                    ]),   \n",
    "                    html.Div([\n",
    "                        html.Span('🥈', style={'fontSize': '24px'}),\n",
    "                        html.Span('  Доля реакции ', style={'fontSize': '12px'}),\n",
    "                        html.Span(id='react2', style={'fontSize': '24px'}),\n",
    "                        html.Span(':  ', style={'fontSize': '12px'}),\n",
    "                        html.Span(id='perc2', style=styles['metric_numbers'])\n",
    "                    ]), \n",
    "                    html.Div([\n",
    "                        html.Span('🥉', style={'fontSize': '24px'}),\n",
    "                        html.Span('  Доля реакции ', style={'fontSize': '12px'}),\n",
    "                        html.Span(id='react3', style={'fontSize': '24px'}),\n",
    "                        html.Span(':   ', style={'fontSize': '12px'}),\n",
    "                        html.Span(id='perc3', style=styles['metric_numbers'])\n",
    "                    ]),         \n",
    "    ])   \n",
    "     \n",
    " ])\n",
    "    \n",
    "   , html.Div(className='row', style={'display': 'flex', 'margin-bottom': '40px'}, children=[\n",
    "        \n",
    "            # Правая колонка \n",
    "            html.Div(style={'width': '47%', 'height': '100%', 'marginRight': '30px'},  children=[\n",
    "                html.Div(className='row', children=[\n",
    "                    html.Div(className='col-md-12', style=styles['graph_container'], children=[  \n",
    "                        html.H4(\"Аудитория на момент измерения\", style=styles['subheader_title']),\n",
    "                         html.P(\"График показывает изменение общего количества подписчиков с течением времени. Он помогает отслеживать динамику роста аудитории и выявлять периоды активного притока или оттока подписчиков. Анализ графика позволяет корректировать стратегию продвижения и создавать контент, который привлечет и удержит больше подписчиков (Процентные значения индикаторов указывают на изменения по сравнению с предыдущими аналогичными периодами).\", style=styles['subheader']),\n",
    "                                               \n",
    "                        dcc.Graph(id='graph2')\n",
    "                    ]),\n",
    "\n",
    "                    html.Div(className='col-md-12',  style={'marginBottom': '40px'}, children=[\n",
    "                        html.H4(\"Динамика подписок\", style=styles['subheader_title']),\n",
    "                        html.P(\"Этот график показывает два ключевых показателя: количество пользователей, которые подписались на канал, и тех, кто отписался. Он помогает отслеживать, насколько эффективно ваш контент привлекает новую аудиторию и удерживает существующую. Анализируя этот график, можно сделать выводы о том, какие периоды были наиболее успешными в привлечении подписчиков, а также выявить моменты, когда наблюдалось значительное снижение аудитории. Этот анализ позволит вам скорректировать стратегию создания контента и время его публикации для достижения лучших результатов.\", style=styles['subheader'])\n",
    "                        , dcc.Graph(id='graph-with-slider')\n",
    "                    ]),\n",
    "\n",
    "\n",
    "                    html.Div(className='col-md-12', style={'marginBottom': '40px', 'marginTop': '0px'}, children=[\n",
    "                        dcc.RangeSlider(\n",
    "                            id='date-slider',\n",
    "                            min=0,\n",
    "                            max=(subs['datetime'].max() - subs['datetime'].min()).total_seconds(),\n",
    "                            value=[0, (subs['datetime'].max() - subs['datetime'].min()).total_seconds()],\n",
    "                            marks={\n",
    "                                int((date - subs['datetime'].min()).total_seconds()): {\n",
    "                                    'label': date.strftime(\"%b %d, %H:%M\"),\n",
    "                                    'style': {'fontSize': '12px'}\n",
    "                                } for date in subs['datetime'][::len(subs) // 5]\n",
    "                            },\n",
    "                            step=None,\n",
    "                            updatemode='drag'\n",
    "                        )\n",
    "                    ]),\n",
    "\n",
    "                    html.Div(className='col-md-12',  style={'marginBottom': '40px'}, children=[\n",
    "                        html.H4(\"Визуализация интереса к контенту\", style=styles['subheader_title']),\n",
    "                        html.P(\"Ось Y здесь показывает, насколько активно аудитория реагирует на ваш контент, а ось X – сколько раз этот контент просмотрен. Чем крупнее пузырек, тем больше реакций собрал пост. Если пузырёк высоко взлетел, значит тема 'зашла' – люди не только смотрят, но и активно реагируют. А вот маленькие и низко расположенные пузырьки подсказывают, что стоит задуматься над изменениями. Этот график поможет вам понять, какие темы цепляют аудиторию, когда лучше всего публиковать новые материалы и как улучшить те посты, которые пока не так популярны.\", style=styles['subheader'])\n",
    "                        #, dcc.Graph(id='graph-with-slider')\n",
    "                    ]),                    \n",
    "\n",
    "\n",
    "                    html.Div(className='col-md-12', style=styles['graph_container'], children=[  \n",
    "                        #html.H4(\"Аудитория на момент измерения\", style=styles['subheader_title']),\n",
    "                         #html.P(\"График показывает изменение общего количества подписчиков с течением времени. Он помогает отслеживать динамику роста аудитории и выявлять периоды активного притока или оттока подписчиков. Анализ графика позволяет корректировать стратегию продвижения и создавать контент, который привлечет и удержит больше подписчиков (Процентные значения индикаторов указывают на изменения по сравнению с предыдущими аналогичными периодами).\", style=styles['subheader']),\n",
    "                         html.Div(\n",
    "                           # className='d-flex justify-content-end mb-2',  # Bootstrap классы для выравнивания по правому краю\n",
    "                            children=[\n",
    "                                html.Button(\"3д\", id=\"btn-3d_2\", n_clicks=0, style=styles['buttons'], className=\"btn btn-primary btn-flat\"),\n",
    "                                html.Button(\"1н\", id=\"btn-1w_2\", n_clicks=0, style=styles['buttons'], className=\"btn btn-primary btn-flat\"),\n",
    "                                html.Button(\"1м\", id=\"btn-1m_2\", n_clicks=0, style=styles['buttons'], className=\"btn btn-primary btn-flat\"),\n",
    "                                html.Button(\"All (6м)\", id=\"btn-all_2\", n_clicks=0, style=styles['buttons'], className=\"btn btn-primary btn-flat\")\n",
    "                            ]\n",
    "                        )                                               \n",
    "                        , dcc.Graph(id='graph6')\n",
    "                    ]),\n",
    "                    \n",
    "                ])\n",
    "            ]),\n",
    "\n",
    "            # Левая колонка с графиками\n",
    "            html.Div(style={'width': '47%', 'height': '100%', 'marginLeft': '30px'}, children=[\n",
    "                     \n",
    "                html.Div(className='row', children=[\n",
    "                    html.Div(className='col-md-12', style=styles['graph_container'], children=[\n",
    "                        html.H4(\"Суточные показатели публикаций\", style=styles['subheader_title']),\n",
    "                         html.P(\"График показывает количество публикаций конкурента. Процентные значения  за разные периоды (день, неделя и месяц) указывают на изменения активности по сравнению с предыдущими аналогичными периодами. Анализ этих данных поможет понять, как часто и интенсивно конкурент публикует материалы, что может быть полезным для корректировки вашей собственной стратегии создания контента.\", style=styles['subheader']),\n",
    "                        dcc.Graph(id='graph1')\n",
    "                    ]),\n",
    "                    \n",
    "                    html.Div(className='col-md-12', children=[\n",
    "                        html.H4(\"График публикаций\", style=styles['subheader_title']),\n",
    "                        html.P(\"Этот график является полезным инструментом для понимания того, когда ваши конкуренты выпускают контент или если вы планируете протестировать новый график публикации своих постов (учитываются последние шесть месяцев).\", style=styles['subheader']),\n",
    "                           # Контейнер для кнопок\n",
    "                        html.Div(\n",
    "                           # className='d-flex justify-content-end mb-2',  # Bootstrap классы для выравнивания по правому краю\n",
    "                            children=[\n",
    "                                html.Button(\"3д\", id=\"btn-3d\", n_clicks=0, style=styles['buttons'], className=\"btn btn-primary btn-flat\"),\n",
    "                                html.Button(\"1н\", id=\"btn-1w\", n_clicks=0, style=styles['buttons'], className=\"btn btn-primary btn-flat\"),\n",
    "                                html.Button(\"1м\", id=\"btn-1m\", n_clicks=0, style=styles['buttons'], className=\"btn btn-primary btn-flat\"),\n",
    "                                html.Button(\"All (6м)\", id=\"btn-all\", n_clicks=0, style=styles['buttons'], className=\"btn btn-primary btn-flat\")\n",
    "                            ]\n",
    "                        )\n",
    "                        \n",
    "                        \n",
    "                        , dcc.Graph(id='graph3')\n",
    "\n",
    "\n",
    "                    ]),\n",
    "\n",
    "                    html.Div(className='col-md-12', style={'overflow-y': 'auto', 'max-height': '870px', 'margin-left': '20px'}, children=[\n",
    "                        html.H4(\"Динамика просмотров по дням\", style=styles['subheader_title']),\n",
    "                        html.P(\"Эта таблица помогает определить оптимальное время для публикаций: если в первые сутки после публикации она собирает более 35% всех просмотров, это успешное время публикации; иначе стоит пересмотреть график размещения контента, чтобы новые публикации не затерялись среди конкурентов. Также можно обнаружить возможную мошенническую активность: например, если за одни сутки видео набирает 80% общего количества просмотров, следует проявить осторожность, проанализировать частоту подобных аномалий и сделать выводы (проценты приведены, как пример).\", style=styles['subheader'])\n",
    "                        \n",
    "                        , dcc.Slider(\n",
    "                            id='hours-slider',\n",
    "                            min=0,\n",
    "                            max=72,\n",
    "                            step=1,\n",
    "                            value=5,\n",
    "                            marks={i: str(i) + 'д' for i in range(1, 73, 4)} \n",
    "                            , className='my-custom-slider' \n",
    "                        ),\n",
    "                        html.Table(id='table-container', style=styles['data_table'], children=[\n",
    "                            html.Thead(children=[\n",
    "                                html.Tr(children=[\n",
    "                                    html.Th('ID поста и дата', style=styles['data_table_header']),\n",
    "                                    html.Th('Текущие просмотры', style=styles['data_table_header']),\n",
    "                                    *[html.Th(f'{i}д', style=styles['data_table_header']) for i in range(1, 25)]\n",
    "                                ])\n",
    "                            ]),\n",
    "                            html.Tbody(id='table-body', children=[])\n",
    "                        ])\n",
    "                    ])\n",
    "\n",
    "                    , html.Div(className='col-md-12', style={'marginTop': '50px'}, children=[\n",
    "                        html.H4(\"Просмотр текста поста и даты по номеру ID: \", style=styles['subheader']),\n",
    "                        # Фильтры\n",
    "                        *filter_components,\n",
    "                                # Таблица\n",
    "                                html.Br(),\n",
    "                                html.Table(id='table_id')                        \n",
    "                    ]),\n",
    "                ])\n",
    "            ]),\n",
    "        \n",
    "        ])\n",
    "    ])\n",
    "], style={'font-family': 'Open Sans, sans-serif'})\n",
    "\n",
    "\n",
    "#----------------------------------------------------------------------------------------------------------------------------\n",
    "#-----------------------------Метрики----------------------------------------------------------------------------------------\n",
    "#----------------------------------------------------------------------------------------------------------------------------\n",
    "\n",
    "\n",
    "# Обновление метрик при выборе канала\n",
    "@app.callback(\n",
    "    [\n",
    "        Output('mean_subs_pos', 'children'),\n",
    "        Output('mean_subs_neg', 'children'),\n",
    "        Output('max_subs_pos', 'children'),\n",
    "        Output('max_subs_neg', 'children'),\n",
    "        Output('mean_posts_day', 'children'),\n",
    "        Output('mean_posts_week', 'children'),\n",
    "        Output('mean_posts_month', 'children'),\n",
    "        Output('mean_views', 'children'),\n",
    "        Output('mean_reacts', 'children'),\n",
    "        Output('mean_idx', 'children'),\n",
    "        Output('react1', 'children'),\n",
    "        Output('perc1', 'children'),\n",
    "        Output('react2', 'children'),\n",
    "        Output('perc2', 'children'),\n",
    "        Output('react3', 'children'),\n",
    "        Output('perc3', 'children')\n",
    "        \n",
    "    ],\n",
    "    Input('channel-dropdown', 'value'))\n",
    "\n",
    "def update_metrics(channel):\n",
    "    mean_subs_pos, mean_subs_neg, max_subs_pos, max_subs_neg = calculate_mean_max_subs(channel)\n",
    "    mean_posts_day, mean_posts_week, mean_posts_month = calculate_mean_posts(channel)\n",
    "    mean_views  = calculate_mean_views(channel)\n",
    "    mean_reacts, mean_idx, react1, perc1, react2, perc2, react3, perc3 = calculate_mean_reacts(channel)\n",
    "    \n",
    "    return str(mean_subs_pos), str(mean_subs_neg), str(max_subs_pos), str(max_subs_neg), str(mean_posts_day),\\\n",
    "    str(mean_posts_week), str(mean_posts_month), str(mean_views),\\\n",
    "    str(mean_reacts), f\"{mean_idx}%\", str(react1), f\"{perc1}%\", str(react2), f\"{perc2}%\", str(react3), f\"{perc3}%\" \n",
    "\n",
    "\n",
    "#----------------------------------------------------------------------------------------------------------------------------\n",
    "#-----------------------------Publications-----------------------------------------------------------------------------------\n",
    "#----------------------------------------------------------------------------------------------------------------------------\n",
    "\n",
    "@app.callback(Output('graph1', 'figure'), [Input('channel-dropdown', 'value')])\n",
    "def update_graph1(channel):\n",
    "    #filtered_df = subdf.query(f\"country=='{country}'\")\n",
    "    subdf = posts[posts.channel_name == channel][['channel_name', 'date', 'cnt']].drop_duplicates()\n",
    "\n",
    "    # Создание subplots\n",
    "    fig = make_subplots(\n",
    "        rows=3,\n",
    "        cols=2,\n",
    "        specs=[\n",
    "            [{\"rowspan\": 3}, {'type': 'indicator'}],\n",
    "            [None, {'type': 'indicator'}],\n",
    "            [None, {'type': 'indicator'}],\n",
    "      ],\n",
    "        vertical_spacing=0.08\n",
    "    )\n",
    "    \n",
    "    mean_cnt = subdf.cnt.mean()\n",
    "    #colors = ['#89cff0' if val > 3*mean_cnt else '#7F7F7F' for val in subdf['cnt']]  # Легкий оттенок коричневого для больших значений\n",
    "    colors = ['#8B4513' if val >= 2*mean_cnt else '#F5DEB3' for val in subdf['cnt']]  # '#f5dfbf'\n",
    "\n",
    "    \n",
    "    fig.add_trace(go.Bar(x = subdf.date, y=subdf.cnt, marker_color=colors,\n",
    "                        hovertemplate='%{x} <br>Публикаций: %{y}<extra></extra>'), row=1, col=1)\n",
    "    period_names = dict({'days':'вчера', 'weeks': 'неделю', 'months': 'месяц'})\n",
    "    \n",
    "    for i, period in enumerate([('days', 'days', 1), ('weeks', 'weeks', 1), ('months', 'months', 1)]):\n",
    "        current = subdf[(subdf.date <= date_ago(period[0])) & (subdf.date > date_ago(period[1], period[2]))].cnt.sum()\n",
    "        previous = subdf[(subdf.date <= date_ago(period[1], period[2])) & (subdf.date > date_ago(period[1], period[2]*2))].cnt.sum()\n",
    "            \n",
    "        fig.add_trace(\n",
    "                go.Indicator(\n",
    "                    value=current,\n",
    "                    title={\"text\": f\"<span style='font-size:0.8em;color:gray'>Публикаций за {period_names[period[0]]}</span>\"},\n",
    "                    mode=\"number+delta\",\n",
    "                    delta={'reference': previous, 'relative': True, \"valueformat\": \".2%\"},\n",
    "                ), row=i+1, col=2\n",
    "            )\n",
    "    \n",
    "    # Настройки стиля\n",
    "    fig.update_layout(\n",
    "       # title_text=f\"Суточные показатели публикаций для канала: {channel}\",\n",
    "        template=\"simple_white\",\n",
    "        font_family=\"Georgia\",\n",
    "        font_size=12,\n",
    "        margin=dict(l=40, r=20, t=40, b=10),\n",
    "        paper_bgcolor='rgba(0,0,0,0)',\n",
    "        plot_bgcolor='rgba(0,0,0,0)',\n",
    "        xaxis=dict(\n",
    "            rangeselector=dict(  # Добавляем элементы управления диапазоном\n",
    "                bgcolor= '#f5dfbf' ,  # Фоновый цвет области с кнопками\n",
    "                font=dict(color=\"#333\"),  # Цвет текста на кнопках\n",
    "                activecolor= '#ffb347',  # Цвет активной кнопки\n",
    "                bordercolor='#f5dfbf',  # Цвет рамки вокруг кнопок                     \n",
    "                buttons=list([\n",
    "                    dict(count=2, label=\"2д\", step=\"day\", stepmode=\"backward\"),\n",
    "                    dict(count=14, label=\"2н\", step=\"day\", stepmode=\"backward\"),\n",
    "                    dict(count=2, label=\"2м\", step=\"month\", stepmode=\"backward\"),\n",
    "                    dict(step=\"all\")  # Кнопка для просмотра всего диапазона\n",
    "                ])\n",
    "            )  ) \n",
    "    )\n",
    "    return fig\n",
    "\n",
    "#----------------------------------------------------------------------------------------------------------------------------\n",
    "#-----------------------------SUBS-------------------------------------------------------------------------------------------\n",
    "#----------------------------------------------------------------------------------------------------------------------------\n",
    "@app.callback(Output('graph2', 'figure'), [Input('channel-dropdown', 'value')])\n",
    "def update_graph1(channel):\n",
    "    \n",
    "    subdf = subs[subs.channel_name == channel][['channel_name', 'date'\n",
    "                                                      ,'subs_cnt', 'subs_change', 'datetime']].drop_duplicates()\n",
    "    subdf.sort_values(by=['channel_name', 'datetime'], inplace=True)\n",
    "    \n",
    "    # Создание subplots\n",
    "    fig = make_subplots(\n",
    "        rows=3,\n",
    "        cols=2,\n",
    "        specs=[\n",
    "            [ {\"rowspan\": 3}, {'type': 'indicator'}],\n",
    "            [None, {'type': 'indicator'}],\n",
    "            [ None, {'type': 'indicator'}],\n",
    "      ],\n",
    "        vertical_spacing=0.08\n",
    "    )\n",
    "    \n",
    "    fig.add_trace(\n",
    "        go.Scatter(\n",
    "            x=subdf.datetime,\n",
    "            y=subdf.subs_cnt,\n",
    "            fill='tozeroy',\n",
    "            mode='lines+markers',\n",
    "            line_color= '#f5dfbf', #'#7F7F7F',\n",
    "            marker_color='#f5dfbf', #'#7F7F7F',\n",
    "            marker_line_color='#f5dfbf', #'#7F7F7F',\n",
    "            marker_line_width=1,\n",
    "            marker_size=5,\n",
    "            showlegend=False,\n",
    "            hovertemplate='%{x}  <br>Подписчиков вс: %{y}<extra></extra>'\n",
    "        ),\n",
    "        row=1,\n",
    "        col=1\n",
    "    )\n",
    "        \n",
    "    period_names = dict({'days':'вчера', 'weeks': 'неделю', 'months': 'месяц'})   \n",
    "    for i, period in enumerate([('days', 'days', 1), ('weeks', 'weeks', 1), ('months', 'months', 1)]):\n",
    "        subdf.sort_values(by='date', inplace=True)\n",
    "        current = subdf[subdf.date <= date_ago(period[0])].subs_change.sum() - subdf[\n",
    "                                                                            subdf.date <= date_ago(period[1], period[2])].subs_change.sum()\n",
    "        previous = subdf[subdf.date <= date_ago(period[1], period[2])].subs_change.sum() - subdf[\n",
    "                                                                            subdf.date <= date_ago(period[1], period[2]*2)].subs_change.sum()\n",
    "        \n",
    "        fig.add_trace(\n",
    "            go.Indicator(\n",
    "                value=current,\n",
    "                title={\"text\": f\"<span style='font-size:0.8em;color:gray'>Подписчиков за {period_names[period[0]]}</span>\"},\n",
    "                mode=\"number+delta\",\n",
    "                delta={'reference': previous, 'relative': True, \"valueformat\": \".2%\"},\n",
    "            ), row=i+1, col=2\n",
    "        )\n",
    "\n",
    "\n",
    "    # Настройки стиля\n",
    "    fig.update_layout(\n",
    "        #title_text=f\"GDP per Capita over Time for {country}\",\n",
    "        template=\"simple_white\",\n",
    "        font_family=\"Georgia\",\n",
    "        font_size=12,\n",
    "        margin=dict(l=10, r=10, t=40, b=10),\n",
    "        paper_bgcolor='rgba(0,0,0,0)',\n",
    "        plot_bgcolor='rgba(0,0,0,0)',\n",
    "        xaxis=dict(\n",
    "            rangeselector=dict(  # Добавляем элементы управления диапазоном\n",
    "                bgcolor= '#f5dfbf' ,  # Фоновый цвет области с кнопками\n",
    "                font=dict(color=\"#333\"),  # Цвет текста на кнопках\n",
    "                activecolor= '#ffb347',  # Цвет активной кнопки\n",
    "                bordercolor='#f5dfbf',  # Цвет рамки вокруг кнопок                    \n",
    "                buttons=list([\n",
    "                    dict(count=2, label=\"2д\", step=\"day\", stepmode=\"backward\"),\n",
    "                    dict(count=14, label=\"2н\", step=\"day\", stepmode=\"backward\"),\n",
    "                    dict(count=2, label=\"2м\", step=\"month\", stepmode=\"backward\"),\n",
    "                    dict(step=\"all\")  # Кнопка для просмотра всего диапазона\n",
    "                ])\n",
    "            )  ) \n",
    "    )\n",
    "    return fig\n",
    "\n",
    "#--------------------------------------------------------------------------------------------------------------------------------\n",
    "#--------------------------------------------------------------------------------------------------------------------------------\n",
    "\n",
    "# Модифицируем существующий callback\n",
    "@app.callback(\n",
    "    Output('graph3', 'figure'),\n",
    "    Input('channel-dropdown', 'value'),\n",
    "    Input(\"btn-3d\", \"n_clicks\"),\n",
    "    Input(\"btn-1w\", \"n_clicks\"),\n",
    "    Input(\"btn-1m\", \"n_clicks\"),\n",
    "    Input(\"btn-all\", \"n_clicks\")\n",
    ")\n",
    "def update_graph3(channel, btn_3d_n_clicks, btn_1w_n_clicks, btn_1m_n_clicks, btn_all_n_clicks):\n",
    "    if channel is None:\n",
    "        return {}\n",
    "        \n",
    "    # Получаем контекст вызова\n",
    "    ctx = dash.callback_context\n",
    "    if not ctx.triggered:\n",
    "        button_id = None\n",
    "    else:\n",
    "        button_id = ctx.triggered[0]['prop_id'].split('.')[0]\n",
    "\n",
    "    # Фильтрация данных в зависимости от нажатой кнопки\n",
    "    if button_id == \"btn-3d\":\n",
    "        filtered_df = posts[(posts.channel_name == channel)&(posts.date>=date_ago('days', 2))]\n",
    "    elif button_id == \"btn-1w\":\n",
    "        filtered_df = posts[(posts.channel_name == channel)&(posts.date>=date_ago('weeks', 1))]\n",
    "    elif button_id == \"btn-1m\":\n",
    "        filtered_df = posts[(posts.channel_name == channel)&(posts.date>=date_ago('months', 1))]\n",
    "    else:\n",
    "        filtered_df = posts[(posts.channel_name == channel)&(posts.date>=date_ago('months', 6))]\n",
    "\n",
    "    # Генерация данных\n",
    "    filtered_df = filtered_df[['date', 'hour', 'cnt']].rename(columns={'cnt': 'publications'}).sort_values('date')\n",
    "    raw_index = filtered_df.set_index(['date', 'hour'])\n",
    "    \n",
    "    dates = pd.to_datetime(filtered_df.date).unique().tolist()\n",
    "    index = pd.MultiIndex.from_product([filtered_df.date.unique(), range(1, 25)], names=['date', 'hour'])\n",
    "    raw = pd.DataFrame(index=index)\n",
    "    df = raw.merge(raw_index, left_index=True, right_index=True, how='left')\n",
    "    df.fillna(0, inplace=True)\n",
    "    df = df.reset_index().drop_duplicates(subset=['date', 'hour']).set_index(['date', 'hour'])\n",
    "    \n",
    "    # Преобразование данных в формат, подходящий для heatmap\n",
    "    z_values = df['publications'].unstack(level=-1)\n",
    "    x_labels = [str(hour) for hour in range(1,25)]\n",
    "    y_labels = [date.strftime('%Y-%m-%d') for date in dates]  \n",
    "    \n",
    "    fig = go.Figure(\n",
    "        data=[\n",
    "           go.Heatmap(\n",
    "                    z= pd.DataFrame([[1] * len(x_labels)]*len(y_labels), columns=range(1,25), index=y_labels), #[[1] * len(x_labels)] * len(y_labels),  # Матрица одинаковых значений для всех ячеек\n",
    "                    \n",
    "                    x=x_labels,\n",
    "                    y=y_labels,\n",
    "                    colorscale=[[0, '#ffb347'], [1, '#ffb347']],  # Градиент от белого к темно-синему\n",
    "                    showscale=False,\n",
    "                    hovertemplate='%{y} <br>%{x} ч <br>Публикаций: %{z}<extra></extra>'\n",
    "                ),\n",
    "                go.Heatmap(\n",
    "                z=z_values,\n",
    "                x=x_labels,\n",
    "                y=y_labels,\n",
    "                colorscale=[[0, '#F5DEB3'], [1, \"#006a4e\"]],  # [[0, \"#e5e4e2\"], [1, \"#006a4e\"]], Серый цвет для фона\n",
    "                showscale=False,\n",
    "                xgap=10,  # Зазор между ячейками по горизонтали\n",
    "                ygap=10,   # Зазор между ячейками по вертикали\n",
    "                hovertemplate='%{y} <br>%{x} ч <br>Публикаций: %{z}<extra></extra>'\n",
    "            )\n",
    "        ],\n",
    "    ).update_layout(\n",
    "        font_family='Arial',\n",
    "    \n",
    "        margin=dict(l=30, r=50, t=50, b=20),\n",
    "        paper_bgcolor='#ffb347',\n",
    "        plot_bgcolor='#ffb347',\n",
    "        legend_title_font_color=\"#212121\",\n",
    "        legend_font_color=\"#212121\",\n",
    "        legend_borderwidth=0,\n",
    "        hoverlabel_font_family='Arial',\n",
    "        hoverlabel_font_size=12,\n",
    "        hoverlabel_font_color='#212121',\n",
    "        hoverlabel_align='auto',\n",
    "        hoverlabel_namelength=-1,\n",
    "        hoverlabel_bgcolor='#FAFAFA',\n",
    "        hoverlabel_bordercolor='#E5E4E2'\n",
    "        \n",
    "    )\n",
    "\n",
    "    # Ограничиваем количество меток на оси Y до 10\n",
    "    if len(y_labels) > 10:\n",
    "        y_labels_subset = y_labels[::max(len(y_labels)//10,1)]\n",
    "    else:\n",
    "        y_labels_subset = y_labels\n",
    "    \n",
    "    # Перемещение подписей часов наверх\n",
    "    fig.update_xaxes(side=\"top\", tickfont=dict(family='Arial', size=12), title_font=dict(family='Arial', size=14))\n",
    "    \n",
    "    fig.update_yaxes(\n",
    "        autorange=\"reversed\",\n",
    "        #dtick=max(len(y_labels) // 10, 1),\n",
    "        ticktext=y_labels,\n",
    "        #tickvals= [datetime.datetime.strptime(date, \"%Y-%m-%d\").timestamp() for date in y_labels_subset],\n",
    "        tickformat=\"%b %d, %y\",\n",
    "        tickfont={\"family\": \"Arial\", \"size\": 8},  # Уменьшаем размер шрифта для компактности\n",
    "        title_font={\"family\": \"Arial\", \"size\": 14}\n",
    "    )\n",
    "    \n",
    "    # Добавляем полосу прокрутки для оси Y\n",
    "    fig.update_layout(\n",
    "        font_size=9,\n",
    "        yaxis_title=\"Дата\",\n",
    "        xaxis_title=\"Часы\",    \n",
    "        yaxis=dict(\n",
    "            autorange=\"reversed\",\n",
    "             # tickangle=45,  # Наклон меток для улучшения читаемости\n",
    " ) \n",
    "    )    \n",
    "    return fig\n",
    "#-----------------------------------------------------------------------------------------------------------------------------------\n",
    "#-----------------------------------------------------------------------------------------------------------------------------------\n",
    "        \n",
    "@app.callback(\n",
    "    Output('graph-with-slider', 'figure'),\n",
    "    Input('channel-dropdown', 'value'),\n",
    "    Input('date-slider', 'value'))\n",
    "def update_graph4(channel, slider_range):\n",
    "    if channel is None or slider_range is None:\n",
    "        return {}\n",
    "        \n",
    "    subdf_channel = subs[subs['channel_name'] == channel]\n",
    "    \n",
    "    # Проверяем, что дата присутствует и не пуста\n",
    "    if len(subdf_channel) == 0 or 'datetime' not in subdf_channel.columns:\n",
    "        return {}    \n",
    "    # Преобразуем строку в datetime\n",
    "    subdf_channel.loc[:, 'datetime'] = pd.to_datetime(subdf_channel['datetime'])\n",
    "    start_time = subdf_channel['datetime'].min() + pd.Timedelta(seconds=slider_range[0])\n",
    "    end_time = subdf_channel['datetime'].min() + pd.Timedelta(seconds=slider_range[1])\n",
    "\n",
    "    filtered_df = subdf_channel[(subdf_channel['datetime'] >= start_time) & (subdf_channel['datetime'] <= end_time)]\n",
    "    \n",
    "    filtered_df_uniq = filtered_df[['date', 'day_change_pos', 'day_change_neg']].drop_duplicates()\n",
    "    \n",
    "    #colors = [ '#A9A9A9' if val < 0 else  '#89cff0' for val in filtered_df['subs_change']]\n",
    "    #colors = [ '#8B0000' if val < 0 else  '#F5DEB3' for val in filtered_df_uniq['subs_change']]\n",
    "\n",
    "    fig = go.Figure()\n",
    "    fig.add_trace(go.Bar(x=filtered_df_uniq['date'], y=filtered_df_uniq['day_change_pos'], marker_color='#F5DEB3', hovertemplate='%{x} <br>Подписались: %{y} <extra></extra>'))\n",
    "    fig.add_trace(go.Bar(x=filtered_df_uniq['date'], y=filtered_df_uniq['day_change_neg'], marker_color='#8B0000', hovertemplate='%{x} <br>Отписались: %{y}<extra></extra>'))\n",
    "\n",
    "    fig.update_layout(\n",
    "        showlegend=False,\n",
    "        paper_bgcolor= '#ffb347', #'#FFFFFF',\n",
    "        plot_bgcolor=  '#ffb347', #'#FFFFFF',\n",
    "        font_family='Georgia',\n",
    "        title_font_size=24,\n",
    "        title_x=0.5,\n",
    "        margin=dict(l=40, r=60, t=40, b=10),\n",
    "        yaxis_title=\"Изменение подписок\",\n",
    "        xaxis_title=\"Дата и время\",\n",
    "        xaxis=dict(\n",
    "            rangeselector=dict(  # Добавляем элементы управления диапазоном\n",
    "                bgcolor= '#f5dfbf' ,  # Фоновый цвет области с кнопками\n",
    "                font=dict(color=\"#333\"),  # Цвет текста на кнопках\n",
    "                activecolor= '#ffb347',  # Цвет активной кнопки\n",
    "                bordercolor='#f5dfbf',  # Цвет рамки вокруг кнопок                \n",
    "                buttons=list([\n",
    "                    dict(count=3, label=\"3д\", step=\"day\", stepmode=\"backward\"),\n",
    "                    dict(count=7, label=\"1н\", step=\"day\", stepmode=\"backward\"),\n",
    "                    dict(count=1, label=\"1м\", step=\"month\", stepmode=\"backward\"),\n",
    "                    dict(step=\"all\")  # Кнопка для просмотра всего диапазона\n",
    "                ])\n",
    "            )  ) \n",
    "    )\n",
    "    return fig\n",
    "\n",
    "\n",
    "@app.callback(\n",
    "    Output('date-slider', 'marks'),\n",
    "    Input('channel-dropdown', 'value'))\n",
    "def update_slider_marks(channel):\n",
    "    if channel is None:\n",
    "        return {}\n",
    "\n",
    "    subdf_channel = subs[subs['channel_name'] == channel]\n",
    "    dates = sorted(subdf_channel.date)\n",
    "    # Преобразуем список строк в список дат\n",
    "    dates = [datetime.datetime.strptime(date,'%Y-%m-%d') for date in dates]\n",
    "    date_min = min(dates)\n",
    "    if len(dates) > 0:\n",
    "        marks = {\n",
    "            int(pd.Timedelta(date - date_min).total_seconds()): {\n",
    "                'label': date.strftime(\"%b %d\"), #format_date(date, \"MMM d\", locale='ru_RU').title()\n",
    "                'style': {\n",
    "                    'fontSize': '12px',\n",
    "                    'color': 'black',\n",
    "                    'backgroundColor': '#f5dfbf', #'white',\n",
    "                    'borderRadius': '5px',\n",
    "                    'padding': '2px',\n",
    "                    'display': 'block',\n",
    "                    'width': 'auto',\n",
    "                    'transform': 'translateX(-50%)'\n",
    "                }\n",
    "            } for date in dates[::len(dates)//6]\n",
    "        }\n",
    "    else:\n",
    "        marks = {}\n",
    "    return marks\n",
    "#--------------------------------------------------------------------------------------------------------------------------------\n",
    "#--------------------------------------------------------------------------------------------------------------------------------\n",
    "@app.callback(\n",
    "    Output(\"table-container\", \"children\"),\n",
    "    Input(\"hours-slider\", \"value\"),\n",
    "     Input(\"channel-dropdown\", \"value\") \n",
    ")\n",
    "def update_table(max_days, channel):\n",
    "    return create_table(post_view, max_days, channel)\n",
    "    \n",
    "#-------------------------------------------------------------------------------------------------------------------------------\n",
    "#--------------------------------------------------------------------------------------------------------------------------------    \n",
    "\n",
    "\n",
    "import colorlover as cl\n",
    "\n",
    "# Модифицируем существующий callback\n",
    "@app.callback(\n",
    "    Output('graph6', 'figure'),\n",
    "    Input('channel-dropdown', 'value'),\n",
    "    Input(\"btn-3d_2\", \"n_clicks\"),\n",
    "    Input(\"btn-1w_2\", \"n_clicks\"),\n",
    "    Input(\"btn-1m_2\", \"n_clicks\"),\n",
    "    Input(\"btn-all_2\", \"n_clicks\")\n",
    ")\n",
    "def update_graph6(channel, btn_3d_n_clicks, btn_1w_n_clicks, btn_1m_n_clicks, btn_all_n_clicks):\n",
    "    if channel is None:\n",
    "        return {}\n",
    "        \n",
    "    # Получаем контекст вызова\n",
    "    ctx = dash.callback_context\n",
    "    if not ctx.triggered:\n",
    "        button_id = None\n",
    "    else:\n",
    "        button_id = ctx.triggered[0]['prop_id'].split('.')[0]\n",
    "\n",
    "    \n",
    "    # Фильтрация данных в зависимости от нажатой кнопки\n",
    "    def buttons_cond(df, channel, button_id):\n",
    "        if button_id == \"btn-3d_2\":\n",
    "            filtered_df = df[(df.channel_name == channel)&(df.post_datetime.str[:10]>=date_ago('days', 2))]\n",
    "        elif button_id == \"btn-1w_2\":\n",
    "            filtered_df = df[(df.channel_name == channel)&(df.post_datetime.str[:10]>=date_ago('weeks', 1))]\n",
    "        elif button_id == \"btn-1m_2\":\n",
    "            filtered_df = df[(df.channel_name == channel)&(df.post_datetime.str[:10]>=date_ago('months', 1))]\n",
    "        else:\n",
    "            filtered_df = df[(df.channel_name == channel)&(df.post_datetime.str[:10]>=date_ago('months', 6))]\n",
    "            \n",
    "        return filtered_df\n",
    "\n",
    "    # Генерация данных\n",
    "    filtered_gr_pvr = buttons_cond(gr_pvr, channel, button_id)\n",
    "    #table\n",
    "    gr_pvr_sum = filtered_gr_pvr.drop(['reaction_type', 'react_cnt'], axis=1).drop_duplicates()\n",
    "\n",
    "    if gr_pvr_sum.shape[0] == 0:\n",
    "        return {}\n",
    "    \n",
    "    # Создаем градиент \n",
    "    colors = cl.scales['9']['seq']['OrRd'][::-1] \n",
    "    \n",
    "# Предположим, что у тебя уже есть DataFrame под названием gr_pvr_sum\n",
    "    fig = go.Figure()\n",
    "    \n",
    "    # Добавление точек на график\n",
    "    fig.add_trace(go.Scatter(\n",
    "        x=gr_pvr_sum['current_views'],\n",
    "        y=gr_pvr_sum['idx_active'],\n",
    "        mode='markers',\n",
    "        marker=dict(\n",
    "            size=gr_pvr_sum['react_cnt_sum'],\n",
    "            color=gr_pvr_sum['current_views'],\n",
    "            colorscale=colors,\n",
    "            showscale=False,  # Скрывает colorbar\n",
    "            sizemode='area',\n",
    "            sizeref=2. * max(0, max(gr_pvr_sum['react_cnt_sum'])) / (18.**2),\n",
    "            sizemin=4\n",
    "        ),\n",
    "        text=gr_pvr_sum[['post_id']],  # Показывает post_id и дату при наведении\n",
    "        hoverinfo='text+x+y+z',  # Настройка информации во всплывающей подсказке\n",
    "        hovertemplate=\n",
    "            '<b>ID Поста:</b> %{text}<br>' +\n",
    "            '<b>Текущие Просмотры:</b> %{x}<br>' +\n",
    "            '<b>Количество реакций:</b> %{marker.size}<br>' +  # Добавлен размер пузыря\n",
    "            '<b>Активность:</b> %{y} %<extra></extra>'\n",
    "    ))\n",
    "    \n",
    "    # Логарифмическая ось X\n",
    "    fig.update_xaxes(type=\"log\")\n",
    "\n",
    "\n",
    "    # Скрыть colorbar\n",
    "    fig.update_layout(coloraxis_showscale=False)\n",
    "\n",
    "    fig.update_layout(    \n",
    "        yaxis_title=\"Индекс активности, %\",\n",
    "        xaxis_title=\"Текущее количество просмотров\",         \n",
    "        xaxis=dict(\n",
    "            showgrid=False,\n",
    "            showline=True,\n",
    "            linecolor='rgb(102, 102, 102)',\n",
    "            tickfont_color='rgb(102, 102, 102)',\n",
    "            showticklabels=True,\n",
    "            #dtick=10,\n",
    "            ticks='outside',\n",
    "            tickcolor='rgb(102, 102, 102)',\n",
    "        ),\n",
    "        margin=dict(l=40, r=60, t=10, b=10),\n",
    "        showlegend=False,\n",
    "        paper_bgcolor='#ffb347',\n",
    "        plot_bgcolor='#ffb347',\n",
    "        hovermode='closest',\n",
    "    )\n",
    "    return fig\n",
    "\n",
    "@app.callback(Output('image_wc', 'src'), Input('channel-dropdown', 'value'))\n",
    "def update_graph7(channel):\n",
    "        \n",
    "    posts_channel = posts[posts['channel_name'] == channel]\n",
    "\n",
    "\n",
    "    words = posts_channel.text.apply(lambda t: list(set([w.lower() for w in nltk.word_tokenize(t)])- puncts - dell_words)).tolist()\n",
    "    df_words = pd.DataFrame(Counter(sum(words, [])).most_common(50), columns = ['word', 'count'])\n",
    "        \n",
    "    def plot_wordcloud(data):\n",
    "        d = {a: x for a, x in data.values}\n",
    "        wc = WordCloud(background_color='#f5dfbf', color_func=gradient_color_func) #, width=480, height=360\n",
    "        wc.fit_words(d)\n",
    "        return wc.to_image()\n",
    "            \n",
    "    def make_image():\n",
    "        img = BytesIO()\n",
    "        plot_wordcloud(data=df_words).save(img, format='PNG')\n",
    "        return 'data:image/png;base64,{}'.format(base64.b64encode(img.getvalue()).decode())\n",
    "    return make_image()\n",
    "\n",
    "\n",
    "@app.callback(\n",
    "    Output('table_id', 'children'),\n",
    "    [Input(f'input_{col}', 'value') for col in filter_columns_table_id]\n",
    ")\n",
    "\n",
    "def update_table(*args):\n",
    "    # Проверка наличия введённых значений\n",
    "    if any(value is not None and value != '' for value in args):\n",
    "        # Получаем текущие значения фильтров\n",
    "        filters = dict(zip(filter_columns_table_id, args))\n",
    "        \n",
    "        # Создаем маску для фильтрации данных\n",
    "        mask = pd.Series(True, index=posts.index)  # Начальная маска\n",
    "        for col, value in filters.items():\n",
    "            if value is not None and value != '':\n",
    "                try:\n",
    "                    # Преобразуем значение в число, если возможно\n",
    "                    numeric_value = float(value)\n",
    "                    \n",
    "                    # Если столбец содержит числа, применяем числовое сравнение\n",
    "                    if pd.api.types.is_numeric_dtype(posts[col]):\n",
    "                        mask &= (posts[col] == numeric_value)\n",
    "                    else:\n",
    "                        # Иначе используем текстовое сравнение\n",
    "                        mask &= (posts[col].astype(str).str.contains(value))\n",
    "                except ValueError:\n",
    "                    # Если преобразование в число невозможно, используем текстовое сравнение\n",
    "                    mask &= (posts[col].astype(str).str.contains(value))\n",
    "                \n",
    "        # Применяем маску к данным\n",
    "        filtered_df = posts[columns_table_id][mask]\n",
    "        \n",
    "        # Формируем таблицу\n",
    "        table_rows = [\n",
    "            html.Tr([html.Th(col) for col in filtered_df.columns]),\n",
    "            *[\n",
    "                html.Tr([html.Td(cell, style={'vertical-align': 'top','padding': '8px'}) for cell in row])\n",
    "                for _, row in filtered_df.iterrows()\n",
    "            ]\n",
    "        ]\n",
    "        \n",
    "        return table_rows\n",
    "    else:\n",
    "        return []  # Возвращаем пустую таблицу, если нет введённых значений\n",
    "\n",
    "\n",
    "\n",
    "if __name__ == '__main__':\n",
    "    app.run_server(debug=True,  port=8011)\n",
    "\n",
    "def server():\n",
    "    return app.server"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "9231755b-4bac-4adf-ac73-15e810d6880c",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.7"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
